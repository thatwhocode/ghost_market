from user_service.repositories.user_repo import UserRepository
from user_service.schemas.user import UserCreate, UserLoginEmail, UserUpdate,  UserLoginUsername, UserRead, AdminStatsRead
from fastapi import HTTPException, status
from user_service.core.security import get_password_hash, verify_password
from shared_packages.core.security import create_access_token
from shared_packages.schemas.token import Token
from jose.jwt import decode, JWTError
from shared_packages.core.config import SharedBaseSettings
settings = SharedBaseSettings()
from sqlalchemy import func, select
from uuid import UUID
class AuthService:
    def __init__(self, userRepo: UserRepository):
        self.user_repo = userRepo
    def _generate_token_response(self, user) -> dict:
        access_token = create_access_token(
            data={
                "sub": str(user.id), 
                "email": user.email, 
                "is_admin": user.is_superuser
            }
        )
        return {"access_token": access_token, "token_type": "bearer"}
    async def register_user(self, user_data: UserCreate):
        email =  await self.user_repo.find_user_email(user_data.email)
        if email :
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, 
                                detail="this email already in use")
    
        username =  await self.user_repo.find_username(user_data.username)
        if username:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST,
                                     detail="this username already exist")
        password = get_password_hash(user_data.password)
        return await self.user_repo.create_user(user_data=user_data, hashed_password=password)
    
    async def login_with_email(self, user_data:UserLoginEmail ) -> Token:
        user  = await self.user_repo.find_user_email(user_email=user_data.email)
        if user == None or not verify_password(user_data.password.get_secret_value(), user.hashed_password):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                 detail="Wrong login or password")
        return self._generate_token_response(user)
    async def login_with_username(self, user_data:UserLoginUsername ) -> Token:
        user  = await self.user_repo.find_username(username=user_data.username)
        if user == None or not verify_password(user_data.password.get_secret_value(), user.hashed_password):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                 detail="Wrong login or password")
        return self._generate_token_response(user)
    async def get_user_from_token(self, token : Token)-> UserRead:
        credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED,
                                               detail="Couldn`t verify credentials",
                                               headers={"WWW-Authenticate: Bearer"})
        try:
            payload = decode(
                token,
                settings.SECRET_KEY,
                algorithms=[settings.ALGORITHM]
            )
            user_id : str = payload.get("sub")
        except JWTError:
            raise credentials_exception
        user = await self.user_repo.find_user_by_id(user_id)
        if user is None:
            raise credentials_exception
        return user
    async def update_profile(self, user_id : UUID, update_data : UserUpdate) -> UserRead:
        data_to_update = update_data.model_dump(exclude_unset=True)
    
        if not data_to_update:
            return await self.user_repo.find_user_by_id(user_id)
        
        return await self.user_repo.update_user(user_id, data_to_update)

    async def list_users(self, skip: int, limit: int):
        return await self.user_repo.get_all_users(skip, limit)

    async def toggle_user_status(self, user_id: UUID, is_active: bool):
        return await self.user_repo.update_user_by_id(user_id, {"is_active": is_active})

    async def apply_reward(self, user_id: UUID, echoes: int, shards: int):
        if echoes > 1_000_000:
            echoes = 1_000_000
        return await self.user_repo.adjust_user_balance(user_id, echoes, shards)

    async def get_stats(self) -> AdminStatsRead:
        data = await self.user_repo.get_admin_stats()
        return AdminStatsRead.model_validate(data)